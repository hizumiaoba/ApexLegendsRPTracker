/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ApexLegendsRPTracker;

public class Library {

	// ランクの区分は以下のRPからスタートします
	public static final int BRONZE = 0;
	public static final int SILVER = 1200;
	public static final int GOLD = 2800;
	public static final int PLATINUM = 4800;
	public static final int DIAMOND = 7200;
	public static final int MASTER_APEXPREDATOR = 10000;

	//JSON形式でRPの取得状況を保存します
	public static boolean writeToJson(int gain) {
		boolean flag = false;
		return flag;
	}

	//マッチで獲得したRPを計算し、最終的な獲得RPのみを返します
	public static int calcRP(int currentRP, int Place, int killCount, int assistCount, boolean isAbandoned) {
		return calcRPWithBreakdown(currentRP, Place, killCount, assistCount, isAbandoned)[5];
	}

	/**
	 * ランクマッチ結果を内訳込みで返します。
	 * 降格保護については引数のcurrentRPから判断し、適用される場合は自動で追加されます。
	 * 番号3、4の結果は適用されない場合、0が格納されています
	 * @param currentRP 現在のRPを格納します
	 * @param Place　マッチ順位を格納します
	 * @param killCount　キル数（アシスト含まず）を格納します
	 * @param assistCount　アシスト数（キル数含まず）を格納します
	 * @param isLossForgivenessActive　降格保護の有無をBooleanで格納します
	 * @param isAbandoned　マッチ放棄の有無をBooleanで格納します
	 * @return　[0]順位ポイント[1]キルポイント（アシスト込み）[2]獲得RP（降格保護なし）[3]マッチ放棄剥奪[4]降格保護[5]最終獲得RP
	 */
	public static int[] calcRPWithBreakdown(int currentRP, int Place, int killCount, int assistCount, boolean isAbandoned) {
		int res[] = {0,0,0,0,0,0};
		int placePoint = getPlaceRP(Place);
		int killPoint;
		int gainRP;
		int matchAbandoned = 0;;
		int downProtection = 0;
		int entryRP = getEntryRP(currentRP);
		if(isAbandoned)
			matchAbandoned = entryRP;
		if(killCount + assistCount > 6) {
			killPoint = 6 * getMultiplier(Place);
		}else {
			killPoint = (killCount + assistCount) * getMultiplier(Place);
		}
		gainRP = placePoint + killPoint + entryRP + matchAbandoned;
		if((currentRP + gainRP) < getNearestRP(currentRP))
			downProtection = getNearestRP(currentRP) - (currentRP + gainRP);
		res[0] = placePoint;
		res[1] = killPoint;
		res[2] = gainRP;
		res[3] = matchAbandoned;
		res[4] = downProtection;
		res[5] = gainRP + downProtection;
		return res;
	}

	public static final int getEntryRP(int currentRP) {
		int result = 1;
		if(currentRP < SILVER) {
			result = 0;
		}else if (currentRP < GOLD) {
			result = -12;
		}else if (currentRP < PLATINUM) {
			result = -24;
		}else if (currentRP < DIAMOND) {
			result = -36;
		}else if(currentRP < MASTER_APEXPREDATOR){
			result = -48;
		}else {
			result = -60;
		}
		return result;
	}

	public static final int getPlaceRP(int place) {
		int result = -1;
		switch(place) {
		case 1:
			result = 100;
			break;
		case 2:
			result = 60;
			break;
		case 3:
			result = 40;
			break;
		case 4:
			result = 40;
			break;
		case 5:
			result = 30;
			break;
		case 6:
			result = 30;
			break;
		case 7:
			result = 20;
			break;
		case 8:
			result = 20;
			break;
		case 9:
			result = 10;
			break;
		case 10:
			result = 10;
			break;
		case 11:
			result = 5;
			break;
		case 12:
			result= 5;
			break;
		case 13:
			result = 5;
			break;
		default :
			result = 0;
			break;
		}
		return result;
	}

	public static final int getMultiplier(int place) {
		int result = -1;
		switch(place) {
		case 1:
			result = 25;
			break;
		case 2:
			result = 20;
			break;
		case 3:
			result = 20;
			break;
		case 4:
			result = 15;
			break;
		case 5:
			result = 15;
			break;
		case 6:
			result = 12;
			break;
		case 7:
			result = 12;
			break;
		case 8:
			result = 12;
			break;
		case 9:
			result = 12;
			break;
		case 10:
			result = 12;
			break;
		default :
			result = 10;
			break;
		}
		return result;
	}

	public static final int getNearestRP(int currentRP) {
		int result = -1;
		if(currentRP < SILVER) {
			result = BRONZE;
		}else if (currentRP < GOLD) {
			result = SILVER;
		}else if (currentRP < PLATINUM) {
			result = GOLD;
		}else if (currentRP < DIAMOND) {
			result = PLATINUM;
		}else if(currentRP < MASTER_APEXPREDATOR){
			result = DIAMOND;
		}else {
			result = MASTER_APEXPREDATOR;
		}
		return result;
	}
}
